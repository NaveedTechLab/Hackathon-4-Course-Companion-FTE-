from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import Dict, Any
import uuid
from database import get_db
from middleware.premium_check import require_premium_access
from schemas.premium_schemas import AssessmentGradeRequest, AssessmentGradeResponse
from services.assessment_grading_service import AssessmentGradingService
from models.subscription import SubscriptionFeature

router = APIRouter()

@router.post("/grade-freeform", response_model=AssessmentGradeResponse)
async def grade_freeform_assessment(
    request: AssessmentGradeRequest,
    db: Session = Depends(get_db),
    user_id: uuid.UUID = Depends(require_premium_access(SubscriptionFeature.ASSESSMENT_GRADING))
) -> AssessmentGradeResponse:
    """
    Grade a free-form assessment response using Claude AI
    """
    try:
        grading_service = AssessmentGradingService()

        result = grading_service.grade_freeform_assessment(
            db=db,
            user_id=user_id,
            question=request.question,
            correct_answer=request.correct_answer,
            student_response=request.student_response,
            rubric=request.rubric.dict() if request.rubric else {},
            assessment_id=request.assessment_id
        )

        if not result["success"]:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Failed to grade assessment"
            )

        assessment_result = result["result"]

        return AssessmentGradeResponse(
            assessment_id=uuid.UUID(assessment_result["assessment_id"]),
            user_id=user_id,
            question=request.question,
            student_response=request.student_response,
            score=assessment_result["score"],
            max_score=assessment_result["max_score"],
            feedback=assessment_result["feedback"],
            strengths=result["grading_analysis"]["strengths"],
            areas_for_improvement=result["grading_analysis"]["areas_for_improvement"],
            misconceptions_identified=result["grading_analysis"]["misconceptions_identified"],
            next_learning_recommendations=result["grading_analysis"]["next_learning_recommendations"],
            graded_at=assessment_result["graded_at"]
        )

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_ERROR,
            detail=f"Internal server error: {str(e)}"
        )


@router.post("/grade-essay", response_model=AssessmentGradeResponse)
async def grade_essay_question(
    request: AssessmentGradeRequest,
    db: Session = Depends(get_db),
    user_id: uuid.UUID = Depends(require_premium_access(SubscriptionFeature.ASSESSMENT_GRADING))
) -> AssessmentGradeResponse:
    """
    Grade an essay question with detailed feedback using Claude AI
    """
    try:
        grading_service = AssessmentGradingService()

        result = grading_service.grade_essay_question(
            db=db,
            user_id=user_id,
            question=request.question,
            student_response=request.student_response,
            rubric=request.rubric.dict() if request.rubric else {}
        )

        if not result["success"]:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Failed to grade essay"
            )

        # For essay grading, we'll return a similar structure
        grading_analysis = result.get("analysis", {})

        return AssessmentGradeResponse(
            assessment_id=request.assessment_id or uuid.uuid4(),
            user_id=user_id,
            question=request.question,
            student_response=request.student_response,
            score=grading_analysis.get("score", 0),
            max_score=grading_analysis.get("max_score", 10),
            feedback=grading_analysis.get("feedback_summary", "Essay feedback generated by AI"),
            strengths=["Well-structured response", "Good use of examples"] if grading_analysis.get("score", 0) > 5 else ["Needs improvement in structure"],
            areas_for_improvement=["Could add more supporting details", "Consider alternative perspectives"] if grading_analysis.get("score", 0) <= 5 else ["Minor improvements possible"],
            misconceptions_identified=[],
            next_learning_recommendations=grading_analysis.get("recommendations", ["Continue practicing essay writing"]),
            graded_at=str(uuid.datetime.datetime.utcnow())
        )

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_ERROR,
            detail=f"Internal server error: {str(e)}"
        )


@router.post("/grade-problem-solving", response_model=AssessmentGradeResponse)
async def grade_problem_solving(
    request: AssessmentGradeRequest,
    db: Session = Depends(get_db),
    user_id: uuid.UUID = Depends(require_premium_access(SubscriptionFeature.ASSESSMENT_GRADING))
) -> AssessmentGradeResponse:
    """
    Grade problem-solving responses with step-by-step analysis using Claude AI
    """
    try:
        grading_service = AssessmentGradingService()

        # For problem solving, we'll use the general grading method but with specific context
        result = grading_service.grade_freeform_assessment(
            db=db,
            user_id=user_id,
            question=request.question,
            correct_answer=request.correct_answer or "Step-by-step solution",
            student_response=request.student_response,
            rubric=request.rubric.dict() if request.rubric else {},
            assessment_id=request.assessment_id
        )

        if not result["success"]:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Failed to grade problem-solving"
            )

        assessment_result = result["result"]

        return AssessmentGradeResponse(
            assessment_id=uuid.UUID(assessment_result["assessment_id"]),
            user_id=user_id,
            question=request.question,
            student_response=request.student_response,
            score=assessment_result["score"],
            max_score=assessment_result["max_score"],
            feedback=assessment_result["feedback"],
            strengths=result["grading_analysis"]["strengths"],
            areas_for_improvement=result["grading_analysis"]["areas_for_improvement"],
            misconceptions_identified=result["grading_analysis"]["misconceptions_identified"],
            next_learning_recommendations=result["grading_analysis"]["next_learning_recommendations"],
            graded_at=assessment_result["graded_at"]
        )

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_ERROR,
            detail=f"Internal server error: {str(e)}"
        )


@router.get("/statistics/{user_id}", response_model=Dict[str, Any])
async def get_grading_statistics(
    user_id: uuid.UUID,
    db: Session = Depends(get_db),
    current_user_id: uuid.UUID = Depends(require_premium_access(SubscriptionFeature.ASSESSMENT_GRADING))
) -> Dict[str, Any]:
    """
    Get statistics about a user's assessment performance
    """
    try:
        # Verify that the requesting user is the same as the target user
        if current_user_id != user_id:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Not authorized to view other users' statistics"
            )

        grading_service = AssessmentGradingService()

        statistics = grading_service.get_grading_statistics(
            db=db,
            user_id=user_id
        )

        return statistics

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_ERROR,
            detail=f"Internal server error: {str(e)}"
        )